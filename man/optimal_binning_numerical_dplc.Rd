% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{optimal_binning_numerical_dplc}
\alias{optimal_binning_numerical_dplc}
\title{Optimal Binning for Numerical Variables using Dynamic Programming with Local Constraints (DPLC)}
\usage{
optimal_binning_numerical_dplc(
  target,
  feature,
  min_bins = 3L,
  max_bins = 5L,
  bin_cutoff = 0.05,
  max_n_prebins = 20L,
  convergence_threshold = 1e-06,
  max_iterations = 1000L
)
}
\arguments{
\item{target}{An integer vector of binary target values (0 or 1).}

\item{feature}{A numeric vector of feature values.}

\item{min_bins}{Minimum number of bins (default: 3).}

\item{max_bins}{Maximum number of bins (default: 5).}

\item{bin_cutoff}{Minimum proportion of total observations for a bin to avoid being merged (default: 0.05).}

\item{max_n_prebins}{Maximum number of pre-bins before the optimization process (default: 20).}

\item{convergence_threshold}{Convergence threshold for the algorithm (default: 1e-6).}

\item{max_iterations}{Maximum number of iterations allowed (default: 1000).}
}
\value{
A list containing the following elements:
\item{bin}{Character vector of bin ranges.}
\item{woe}{Numeric vector of WoE values for each bin.}
\item{iv}{Numeric vector of Information Value (IV) for each bin.}
\item{count}{Numeric vector of total observations in each bin.}
\item{count_pos}{Numeric vector of positive target observations in each bin.}
\item{count_neg}{Numeric vector of negative target observations in each bin.}
\item{cutpoints}{Numeric vector of cut points to generate the bins.}
\item{converged}{Logical indicating if the algorithm converged.}
\item{iterations}{Integer number of iterations run by the algorithm.}
}
\description{
Performs optimal binning for numerical variables using a Dynamic Programming with Local Constraints (DPLC) approach. It creates optimal bins for a numerical feature based on its relationship with a binary target variable, maximizing the predictive power while respecting user-defined constraints and enforcing monotonicity.
}
\details{
The Dynamic Programming with Local Constraints (DPLC) algorithm for numerical variables works as follows:
\enumerate{
\item Perform initial pre-binning based on quantiles of the feature distribution.
\item Calculate initial counts and Weight of Evidence (WoE) for each bin.
\item Enforce monotonicity of WoE values across bins by merging adjacent non-monotonic bins.
\item Ensure the number of bins is between \code{min_bins} and \code{max_bins}:
}
\itemize{
\item Merge bins with the smallest WoE difference if above \code{max_bins}.
\item Handle rare bins by merging those below the \code{bin_cutoff} threshold.
}
\enumerate{
\item Calculate final Information Value (IV) for each bin.
}

The algorithm aims to create bins that maximize the predictive power of the numerical variable while adhering to the specified constraints. It enforces monotonicity of WoE values, which is particularly useful for credit scoring and risk modeling applications.

Weight of Evidence (WoE) is calculated as:
\deqn{WoE = \ln\left(\frac{\text{Positive Rate}}{\text{Negative Rate}}\right)}

Information Value (IV) is calculated as:
\deqn{IV = (\text{Positive Rate} - \text{Negative Rate}) \times WoE}
}
\examples{
# Create sample data
set.seed(123)
n <- 1000
target <- sample(0:1, n, replace = TRUE)
feature <- rnorm(n)

# Run optimal binning
result <- optimal_binning_numerical_dplc(target, feature, min_bins = 2, max_bins = 4)

# Print results
print(result)

}
