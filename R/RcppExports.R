# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Performs optimal binning of a categorical variable for Weight of Evidence (WoE) and Information Value (IV)
NULL

#' Performs optimal binning of a numeric variable for Weight of Evidence (WoE) and Information Value (IV) using the Minimum Description Length Principle (MDLP) criterion
#'
#' This function processes a numeric variable and creates pre-bins based on unique values. It iteratively splits bins using the MDLP criterion to maximize information gain, ensuring monotonicity of event rates while respecting the minimum number of bad events (\code{min_bads}) per bin. It also calculates WoE and IV for the generated bins.
#'
#' @param target Integer vector representing the binary target variable, where 1 indicates a positive event (e.g., default) and 0 indicates a negative event (e.g., non-default).
#' @param feature Numeric vector representing the numeric variable to be binned.
#' @param min_bins (Optional) Minimum number of bins to generate. Default is 2.
#' @param max_bins (Optional) Maximum number of bins to generate. Default is 7.
#' @param bin_cutoff (Optional) Cutoff value that determines the frequency of values to define pre-bins. Default is 0.05.
#' @param min_bads (Optional) Minimum proportion of bad events (positive target events) that a bin must contain. Default is 0.05.
#' @param max_n_prebins (Optional) Maximum number of pre-bins to consider before final binning. Default is 20.
#'
#' @return A list with the following elements:
#' \itemize{
#'   \item \code{feature_woe}: Numeric vector with the WoE assigned to each instance of the processed numeric variable.
#'   \item \code{bin}: DataFrame with the generated bins, containing the following fields:
#'     \itemize{
#'       \item \code{bin}: String representing the range of values for each bin.
#'       \item \code{woe}: Weight of Evidence (WoE) for each bin.
#'       \item \code{iv}: Information Value (IV) for each bin.
#'       \item \code{count}: Total number of observations in each bin.
#'       \item \code{count_pos}: Count of positive events in each bin.
#'       \item \code{count_neg}: Count of negative events in each bin.
#'     }
#'   \item \code{woe}: Numeric vector with the WoE for each bin.
#'   \item \code{iv}: Total Information Value (IV) calculated for the variable.
#'   \item \code{pos}: Vector with the count of positive events in each bin.
#'   \item \code{neg}: Vector with the count of negative events in each bin.
#' }
#'
#'
NULL

OptimalBinningCategoricalMIP <- function(target, feature, cat_cutoff = 0.05, min_bins = 2L, max_bins = 5L) {
    .Call(`_OptimalBinningWoE_OptimalBinningCategoricalMIP`, target, feature, cat_cutoff, min_bins, max_bins)
}

#' Performs optimal binning of a categorical variable for Weight of Evidence (WoE) and Information Value (IV) using Monotonic Optimal Binning (MOB)
#'
#' This function processes a categorical variable by grouping rare categories, ordering them by event rate, and generating bins to maximize WoE monotonicity. It also applies constraints to ensure that bins have a minimum number of bad events (min_bads) and calculates WoE and IV for the generated bins.
#'
#' @param target Integer vector representing the binary target variable, where 1 indicates a positive event (e.g., default) and 0 indicates a negative event (e.g., non-default).
#' @param feature Character vector representing the categorical variable to be binned.
#' @param min_bins (Optional) Minimum number of bins to generate. Default is 2.
#' @param max_bins (Optional) Maximum number of bins to generate. Default is 7.
#' @param cat_cutoff (Optional) Frequency cutoff value, below which categories are grouped into "Other". Default is 0.05.
#' @param min_bads (Optional) Minimum proportion of bad events that a bin must contain. Default is 0.05.
#' @param max_n_prebins (Optional) Maximum number of pre-bins to consider before final binning. Default is 20.
#'
#' @return A list with the following elements:
#' \itemize{
#'   \item \code{feature_woe}: Numeric vector with the WoE assigned to each instance of the processed categorical variable.
#'   \item \code{bin}: DataFrame with the generated bins, containing the following fields:
#'     \itemize{
#'       \item \code{bin}: Names of the categories grouped into each bin.
#'       \item \code{woe}: Weight of Evidence (WoE) for each bin.
#'       \item \code{iv}: Information Value (IV) for each bin.
#'       \item \code{count}: Total number of observations in each bin.
#'       \item \code{count_pos}: Count of positive events in each bin.
#'       \item \code{count_neg}: Count of negative events in each bin.
#'     }
#'   \item \code{woe}: Numeric vector with the WoE for each bin.
#'   \item \code{iv}: Total Information Value (IV) calculated for the variable.
#'   \item \code{pos}: Vector with the count of positive events in each bin.
#'   \item \code{neg}: Vector with the count of negative events in each bin.
#' }
#'
#'
OptimalBinningCategoricalMOB <- function(target, feature, min_bins = 2L, max_bins = 7L, cat_cutoff = 0.05, min_bads = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_OptimalBinningCategoricalMOB`, target, feature, min_bins, max_bins, cat_cutoff, min_bads, max_n_prebins)
}

OptimalBinningCategoricalChiMerge <- function(target, feature, min_bins = 2L, max_bins = 7L, pvalue_threshold = 0.05, cat_cutoff = 0.05, min_bads = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_OptimalBinningCategoricalChiMerge`, target, feature, min_bins, max_bins, pvalue_threshold, cat_cutoff, min_bads, max_n_prebins)
}

OptimalBinningCategoricalMDLP <- function(target, feature, min_bins = 2L, max_bins = 7L, cat_cutoff = 0.05, min_bads = 0.05) {
    .Call(`_OptimalBinningWoE_OptimalBinningCategoricalMDLP`, target, feature, min_bins, max_bins, cat_cutoff, min_bads)
}

OptimalBinningCategoricalCAIM <- function(target, feature, min_bins = 2L, max_bins = 7L, cat_cutoff = 0.05, min_bads = 0.05) {
    .Call(`_OptimalBinningWoE_OptimalBinningCategoricalCAIM`, target, feature, min_bins, max_bins, cat_cutoff, min_bads)
}

OptimalBinningCategoricalIV <- function(target, feature, min_bins = 2L, max_bins = 7L, cat_cutoff = 0.05, min_bads = 0.05) {
    .Call(`_OptimalBinningWoE_OptimalBinningCategoricalIV`, target, feature, min_bins, max_bins, cat_cutoff, min_bads)
}

OptimalBinningNumericMIP <- function(target, feature, min_bins = 2L, max_bins = 7L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_OptimalBinningNumericMIP`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

OptimalBinningNumericMOB <- function(target, feature, min_bins = 2L, max_bins = 7L, bin_cutoff = 0.05, min_bads = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_OptimalBinningNumericMOB`, target, feature, min_bins, max_bins, bin_cutoff, min_bads, max_n_prebins)
}

OptimalBinningNumericChiMerge <- function(target, feature, min_bins = 2L, max_bins = 7L, pvalue_threshold = 0.05, bin_cutoff = 0.05, min_bads = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_OptimalBinningNumericChiMerge`, target, feature, min_bins, max_bins, pvalue_threshold, bin_cutoff, min_bads, max_n_prebins)
}

OptimalBinningNumericMDLP <- function(target, feature, min_bins = 2L, max_bins = 7L, bin_cutoff = 0.05, min_bads = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_OptimalBinningNumericMDLP`, target, feature, min_bins, max_bins, bin_cutoff, min_bads, max_n_prebins)
}

#' Performs optimal binning of a numeric variable for Weight of Evidence (WoE) and Information Value (IV) using the Class-Attribute Interdependence Maximization (CAIM) criterion
#'
#' This function processes a numeric variable by creating pre-bins based on unique values. It iteratively merges or splits bins to maximize the CAIM criterion, ensuring monotonicity of event rates while respecting the minimum number of bad events (\code{min_bads}) per bin. It also calculates WoE and IV for the generated bins.
#'
#' @param target Integer vector representing the binary target variable, where 1 indicates a positive event (e.g., default) and 0 indicates a negative event (e.g., non-default).
#' @param feature Numeric vector representing the numeric variable to be binned.
#' @param min_bins (Optional) Minimum number of bins to generate. Default is 2.
#' @param max_bins (Optional) Maximum number of bins to generate. Default is 7.
#' @param bin_cutoff (Optional) Cutoff value that determines the frequency of values to define pre-bins. Default is 0.05.
#' @param min_bads (Optional) Minimum proportion of bad events (positive target events) that a bin must contain. Default is 0.05.
#' @param max_n_prebins (Optional) Maximum number of pre-bins to consider before final binning. Default is 20.
#'
#' @return A list with the following elements:
#' \itemize{
#'   \item \code{feature_woe}: Numeric vector with the WoE assigned to each instance of the processed numeric variable.
#'   \item \code{bin}: DataFrame with the generated bins, containing the following fields:
#'     \itemize{
#'       \item \code{bin}: String representing the range of values for each bin.
#'       \item \code{woe}: Weight of Evidence (WoE) for each bin.
#'       \item \code{iv}: Information Value (IV) for each bin.
#'       \item \code{count}: Total number of observations in each bin.
#'       \item \code{count_pos}: Count of positive events in each bin.
#'       \item \code{count_neg}: Count of negative events in each bin.
#'     }
#'   \item \code{woe}: Numeric vector with the WoE for each bin.
#'   \item \code{iv}: Total Information Value (IV) calculated for the variable.
#'   \item \code{pos}: Vector with the count of positive events in each bin.
#'   \item \code{neg}: Vector with the count of negative events in each bin.
#' }
#'
OptimalBinningNumericCAIM <- function(target, feature, min_bins = 2L, max_bins = 7L, bin_cutoff = 0.05, min_bads = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_OptimalBinningNumericCAIM`, target, feature, min_bins, max_bins, bin_cutoff, min_bads, max_n_prebins)
}

OptimalBinningNumericPAVA <- function(target, feature, max_bins = 7L, bin_cutoff = 0.05, min_bads = 0.05, max_n_prebins = 20L, monotonicity_direction = "increase") {
    .Call(`_OptimalBinningWoE_OptimalBinningNumericPAVA`, target, feature, max_bins, bin_cutoff, min_bads, max_n_prebins, monotonicity_direction)
}

OptimalBinningNumericTree <- function(target, feature, max_bins = 7L, lambda = 0.1, min_bin_size = 0.05, min_iv_gain = 0.01, max_depth = 10L, monotonicity_direction = "increase") {
    .Call(`_OptimalBinningWoE_OptimalBinningNumericTree`, target, feature, max_bins, lambda, min_bin_size, min_iv_gain, max_depth, monotonicity_direction)
}

OptimalBinningCategoricalBreakList <- function(target, feature, predefined_bins) {
    .Call(`_OptimalBinningWoE_OptimalBinningCategoricalBreakList`, target, feature, predefined_bins)
}

OptimalBinningNumericalBreakList <- function(target, feature, break_points) {
    .Call(`_OptimalBinningWoE_OptimalBinningNumericalBreakList`, target, feature, break_points)
}

#' Preprocesses a numeric or categorical variable for optimal binning with handling of missing values and outliers
#'
#' This function preprocesses a given numeric or categorical feature, handling missing values and outliers based on the specified method. It can process both numeric and categorical features and supports outlier detection through various methods, including IQR, Z-score, and Grubbs' test. The function also generates summary statistics before and after preprocessing.
#'
#' @param target Numeric vector representing the binary target variable, where 1 indicates a positive event (e.g., default) and 0 indicates a negative event (e.g., non-default).
#' @param feature Numeric or character vector representing the feature to be binned.
#' @param num_miss_value (Optional) Numeric value to replace missing values in numeric features. Default is -999.0.
#' @param char_miss_value (Optional) String value to replace missing values in categorical features. Default is "N/A".
#' @param outlier_method (Optional) Method to detect outliers. Choose from "iqr", "zscore", or "grubbs". Default is "iqr".
#' @param outlier_process (Optional) Boolean flag indicating whether outliers should be processed. Default is FALSE.
#' @param preprocess (Optional) Character vector specifying what to return: "feature", "report", or "both". Default is "both".
#' @param iqr_k (Optional) The multiplier for the interquartile range (IQR) when using the IQR method to detect outliers. Default is 1.5.
#' @param zscore_threshold (Optional) The threshold for Z-score to detect outliers. Default is 3.0.
#' @param grubbs_alpha (Optional) The significance level for Grubbs' test to detect outliers. Default is 0.05.
#'
#' @return A list containing the following elements based on the \code{preprocess} parameter:
#' \itemize{
#'   \item \code{preprocess}: A DataFrame containing the original and preprocessed feature values.
#'   \item \code{report}: A DataFrame summarizing the variable type, number of missing values, number of outliers (for numeric features), and statistics before and after preprocessing.
#' }
#'
#' @details
#' The function can handle both numeric and categorical features. For numeric features, it replaces missing values with \code{num_miss_value} and can apply outlier detection using different methods. For categorical features, it replaces missing values with \code{char_miss_value}. The function can return the preprocessed feature and/or a report with summary statistics.
#'
#' @examples
#' \dontrun{
#' target <- c(0, 1, 1, 0, 1)
#' feature_numeric <- c(10, 20, NA, 40, 50)
#' feature_categorical <- c("A", "B", NA, "B", "A")
#' result <- OptimalBinningDataPreprocessor(target, feature_numeric, outlier_process = TRUE)
#' result <- OptimalBinningDataPreprocessor(target, feature_categorical)
#' }
#' @export
OptimalBinningDataPreprocessor <- function(target, feature, num_miss_value = -999.0, char_miss_value = "N/A", outlier_method = "iqr", outlier_process = FALSE, preprocess = as.character( c("both")), iqr_k = 1.5, zscore_threshold = 3.0, grubbs_alpha = 0.05) {
    .Call(`_OptimalBinningWoE_OptimalBinningDataPreprocessor`, target, feature, num_miss_value, char_miss_value, outlier_method, outlier_process, preprocess, iqr_k, zscore_threshold, grubbs_alpha)
}

#' Generates a Gains Table from the results of optimal binning
#'
#' This function takes the result of the optimal binning process and generates a detailed gains table. The gains table includes metrics such as the Weight of Evidence (WoE), Information Value (IV), cumulative positive and negative percentages, Kolmogorov-Smirnov (KS) statistic, odds ratio, lift, and Gini contribution for each bin.
#'
#' @param binning_result A list containing the binning results, which must include a data frame with the following columns: "bin", "count", "count_pos", "count_neg", and "woe".
#'
#' @return A data frame containing the following columns for each bin:
#' \itemize{
#'   \item \code{bin}: The bin labels.
#'   \item \code{count}: Total count of observations in the bin.
#'   \item \code{pos}: Count of positive events in the bin.
#'   \item \code{neg}: Count of negative events in the bin.
#'   \item \code{woe}: Weight of Evidence (WoE) for the bin.
#'   \item \code{iv}: Information Value (IV) contribution for the bin.
#'   \item \code{total_iv}: Total Information Value (IV) across all bins.
#'   \item \code{cum_pos}: Cumulative count of positive events up to the current bin.
#'   \item \code{cum_neg}: Cumulative count of negative events up to the current bin.
#'   \item \code{pos_rate}: Rate of positive events within the bin.
#'   \item \code{neg_rate}: Rate of negative events within the bin.
#'   \item \code{pos_perc}: Percentage of positive events relative to the total positive events.
#'   \item \code{neg_perc}: Percentage of negative events relative to the total negative events.
#'   \item \code{count_perc}: Percentage of total observations in the bin.
#'   \item \code{cum_count_perc}: Cumulative percentage of observations up to the current bin.
#'   \item \code{cum_pos_perc}: Cumulative percentage of positive events up to the current bin.
#'   \item \code{cum_neg_perc}: Cumulative percentage of negative events up to the current bin.
#'   \item \code{cum_pos_perc_total}: Cumulative percentage of positive events relative to total observations.
#'   \item \code{cum_neg_perc_total}: Cumulative percentage of negative events relative to total observations.
#'   \item \code{odds_pos}: Odds of positive events in the bin.
#'   \item \code{odds_ratio}: Odds ratio of positive events compared to the total population.
#'   \item \code{lift}: Lift of the bin, calculated as the ratio of the positive rate in the bin to the overall positive rate.
#'   \item \code{ks}: Kolmogorov-Smirnov statistic, measuring the difference between cumulative positive and negative percentages.
#'   \item \code{gini_contribution}: Contribution to the Gini coefficient for each bin.
#' }
#'
#' @examples
#' \dontrun{
#' binning_result <- OptimalBinning(target, feature)
#' gains_table <- OptimalBinningGainsTable(binning_result)
#' }
#'
#' @export
OptimalBinningGainsTable <- function(binning_result) {
    .Call(`_OptimalBinningWoE_OptimalBinningGainsTable`, binning_result)
}

#' Generates a Gains Table from the Weight of Evidence (WoE) and target feature data
#'
#' This function takes a numeric vector of Weight of Evidence (WoE) values and the corresponding binary target variable to generate a gains table. The table includes key metrics such as counts, event rates, cumulative sums, Kolmogorov-Smirnov (KS) statistic, Information Value (IV), odds ratio, lift, and Gini contribution for each unique WoE bin.
#'
#' @param feature_woe Numeric vector representing the Weight of Evidence (WoE) values for each observation.
#' @param target Numeric vector representing the binary target variable, where 1 indicates a positive event (e.g., default) and 0 indicates a negative event (e.g., non-default).
#'
#' @return A data frame containing the following columns for each unique WoE bin:
#' \itemize{
#'   \item \code{bin}: The bin labels.
#'   \item \code{count}: Total count of observations in each bin.
#'   \item \code{pos}: Count of positive events in each bin.
#'   \item \code{neg}: Count of negative events in each bin.
#'   \item \code{woe}: Weight of Evidence (WoE) value for each bin.
#'   \item \code{iv}: Information Value (IV) contribution for each bin.
#'   \item \code{total_iv}: Total Information Value (IV) across all bins.
#'   \item \code{cum_pos}: Cumulative count of positive events up to the current bin.
#'   \item \code{cum_neg}: Cumulative count of negative events up to the current bin.
#'   \item \code{pos_rate}: Rate of positive events in each bin.
#'   \item \code{neg_rate}: Rate of negative events in each bin.
#'   \item \code{pos_perc}: Percentage of positive events relative to the total positive events.
#'   \item \code{neg_perc}: Percentage of negative events relative to the total negative events.
#'   \item \code{count_perc}: Percentage of total observations in each bin.
#'   \item \code{cum_count_perc}: Cumulative percentage of observations up to the current bin.
#'   \item \code{cum_pos_perc}: Cumulative percentage of positive events up to the current bin.
#'   \item \code{cum_neg_perc}: Cumulative percentage of negative events up to the current bin.
#'   \item \code{cum_pos_perc_total}: Cumulative percentage of positive events relative to the total observations.
#'   \item \code{cum_neg_perc_total}: Cumulative percentage of negative events relative to the total observations.
#'   \item \code{odds_pos}: Odds of positive events in each bin.
#'   \item \code{odds_ratio}: Odds ratio of positive events in the bin compared to the total population.
#'   \item \code{lift}: Lift of the bin, calculated as the ratio of the positive rate in the bin to the overall positive rate.
#'   \item \code{ks}: Kolmogorov-Smirnov statistic, measuring the difference between cumulative positive and negative percentages.
#'   \item \code{gini_contribution}: Contribution to the Gini coefficient for each bin.
#' }
#'
#' @details
#' The function assumes that both \code{feature_woe} and \code{target} have the same length. It groups the target values by the unique WoE values, computes various metrics for each group, and returns a comprehensive gains table.
#'
#' @examples
#' \dontrun{
#' feature_woe <- c(-0.5, 0.2, 0.2, -0.5, 0.3)
#' target <- c(1, 0, 1, 0, 1)
#' gains_table <- OptimalBinningGainsTableFeature(feature_woe, target)
#' }
#'
OptimalBinningGainsTableFeature <- function(feature_woe, target) {
    .Call(`_OptimalBinningWoE_OptimalBinningGainsTableFeature`, feature_woe, target)
}

