# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

optimal_binning_categorical_oslp <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L, monotonic = TRUE) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_oslp`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins, monotonic)
}

optimal_binning_categorical_cm <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_cm`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_dplc <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_dplc`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_fetb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_fetb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_gab <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L, population_size = 100L, num_generations = 100L, mutation_rate = 0.1, crossover_rate = 0.8, time_limit_seconds = 300L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_gab`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins, population_size, num_generations, mutation_rate, crossover_rate, time_limit_seconds)
}

optimal_binning_categorical_gmb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_gmb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_ivb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_ivb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_ldb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_ldb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_mba <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_mba`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_mblp <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_mblp`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_milp <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_milp`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_mob <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_mob`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_obnp <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_obnp`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_sab <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L, initial_temperature = 1.0, cooling_rate = 0.995, max_iterations = 1000L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_sab`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins, initial_temperature, cooling_rate, max_iterations)
}

optimal_binning_categorical_sblp <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_sblp`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_swb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_swb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_categorical_udt <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_categorical_udt`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_bb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L, is_monotonic = TRUE) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_bb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins, is_monotonic)
}

optimal_binning_numerical_bs <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_bs`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_cart <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L, is_monotonic = TRUE) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_cart`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins, is_monotonic)
}

optimal_binning_numerical_cm <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_cm`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_dpb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L, n_threads = 1L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_dpb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins, n_threads)
}

optimal_binning_numerical_dplc <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_dplc`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_eb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L, n_threads = 1L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_eb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins, n_threads)
}

optimal_binning_numerical_eblc <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_eblc`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_efb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_efb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_ewb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_ewb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_fetb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_fetb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_gab <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_gab`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_gmb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_gmb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_ir <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_ir`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_ivb <- function(target, feature, min_bins = 3L, max_bins = 5L, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_ivb`, target, feature, min_bins, max_bins, max_n_prebins)
}

optimal_binning_numerical_jnbo <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_jnbo`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_kmb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_kmb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_ldb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_ldb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_lpdb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_lpdb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_mba <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L, n_threads = 1L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_mba`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins, n_threads)
}

optimal_binning_numerical_mblp <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_mblp`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_mdlp <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_mdlp`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_milp <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L, n_threads = 1L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_milp`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins, n_threads)
}

optimal_binning_numerical_mob <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_mob`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_obnp <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_obnp`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_oslp <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_oslp`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_plaob <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_plaob`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_qb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_qb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_sab <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_sab`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_sbb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_sbb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_mrblp <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L, n_threads = 1L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_mrblp`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins, n_threads)
}

optimal_binning_numerical_swb <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_swb`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_ubsd <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_ubsd`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

optimal_binning_numerical_udt <- function(target, feature, min_bins = 3L, max_bins = 5L, bin_cutoff = 0.05, max_n_prebins = 20L) {
    .Call(`_OptimalBinningWoE_optimal_binning_numerical_udt`, target, feature, min_bins, max_bins, bin_cutoff, max_n_prebins)
}

#' Preprocesses a numeric or categorical variable for optimal binning with handling of missing values and outliers
#'
#' This function preprocesses a given numeric or categorical feature, handling missing values and outliers based on the specified method. It can process both numeric and categorical features and supports outlier detection through various methods, including IQR, Z-score, and Grubbs' test. The function also generates summary statistics before and after preprocessing.
#'
#' @param target Numeric vector representing the binary target variable, where 1 indicates a positive event (e.g., default) and 0 indicates a negative event (e.g., non-default).
#' @param feature Numeric or character vector representing the feature to be binned.
#' @param num_miss_value (Optional) Numeric value to replace missing values in numeric features. Default is -999.0.
#' @param char_miss_value (Optional) String value to replace missing values in categorical features. Default is "N/A".
#' @param outlier_method (Optional) Method to detect outliers. Choose from "iqr", "zscore", or "grubbs". Default is "iqr".
#' @param outlier_process (Optional) Boolean flag indicating whether outliers should be processed. Default is FALSE.
#' @param preprocess (Optional) Character vector specifying what to return: "feature", "report", or "both". Default is "both".
#' @param iqr_k (Optional) The multiplier for the interquartile range (IQR) when using the IQR method to detect outliers. Default is 1.5.
#' @param zscore_threshold (Optional) The threshold for Z-score to detect outliers. Default is 3.0.
#' @param grubbs_alpha (Optional) The significance level for Grubbs' test to detect outliers. Default is 0.05.
#'
#' @return A list containing the following elements based on the \code{preprocess} parameter:
#' \itemize{
#'   \item \code{preprocess}: A DataFrame containing the original and preprocessed feature values.
#'   \item \code{report}: A DataFrame summarizing the variable type, number of missing values, number of outliers (for numeric features), and statistics before and after preprocessing.
#' }
#'
#' @details
#' The function can handle both numeric and categorical features. For numeric features, it replaces missing values with \code{num_miss_value} and can apply outlier detection using different methods. For categorical features, it replaces missing values with \code{char_miss_value}. The function can return the preprocessed feature and/or a report with summary statistics.
#'
#' @examples
#' \dontrun{
#' target <- c(0, 1, 1, 0, 1)
#' feature_numeric <- c(10, 20, NA, 40, 50)
#' feature_categorical <- c("A", "B", NA, "B", "A")
#' result <- OptimalBinningDataPreprocessor(target, feature_numeric, outlier_process = TRUE)
#' result <- OptimalBinningDataPreprocessor(target, feature_categorical)
#' }
#' @export
OptimalBinningDataPreprocessor <- function(target, feature, num_miss_value = -999.0, char_miss_value = "N/A", outlier_method = "iqr", outlier_process = FALSE, preprocess = as.character( c("both")), iqr_k = 1.5, zscore_threshold = 3.0, grubbs_alpha = 0.05) {
    .Call(`_OptimalBinningWoE_OptimalBinningDataPreprocessor`, target, feature, num_miss_value, char_miss_value, outlier_method, outlier_process, preprocess, iqr_k, zscore_threshold, grubbs_alpha)
}

#' Generates a Gains Table from the results of optimal binning
#'
#' This function takes the result of the optimal binning process and generates a detailed gains table. The gains table includes metrics such as the Weight of Evidence (WoE), Information Value (IV), cumulative positive and negative percentages, Kolmogorov-Smirnov (KS) statistic, odds ratio, lift, and Gini contribution for each bin.
#'
#' @param binning_result A list containing the binning results, which must include a data frame with the following columns: "bin", "count", "count_pos", "count_neg", and "woe".
#'
#' @return A data frame containing the following columns for each bin:
#' \itemize{
#'   \item \code{bin}: The bin labels.
#'   \item \code{count}: Total count of observations in the bin.
#'   \item \code{pos}: Count of positive events in the bin.
#'   \item \code{neg}: Count of negative events in the bin.
#'   \item \code{woe}: Weight of Evidence (WoE) for the bin.
#'   \item \code{iv}: Information Value (IV) contribution for the bin.
#'   \item \code{total_iv}: Total Information Value (IV) across all bins.
#'   \item \code{cum_pos}: Cumulative count of positive events up to the current bin.
#'   \item \code{cum_neg}: Cumulative count of negative events up to the current bin.
#'   \item \code{pos_rate}: Rate of positive events within the bin.
#'   \item \code{neg_rate}: Rate of negative events within the bin.
#'   \item \code{pos_perc}: Percentage of positive events relative to the total positive events.
#'   \item \code{neg_perc}: Percentage of negative events relative to the total negative events.
#'   \item \code{count_perc}: Percentage of total observations in the bin.
#'   \item \code{cum_count_perc}: Cumulative percentage of observations up to the current bin.
#'   \item \code{cum_pos_perc}: Cumulative percentage of positive events up to the current bin.
#'   \item \code{cum_neg_perc}: Cumulative percentage of negative events up to the current bin.
#'   \item \code{cum_pos_perc_total}: Cumulative percentage of positive events relative to total observations.
#'   \item \code{cum_neg_perc_total}: Cumulative percentage of negative events relative to total observations.
#'   \item \code{odds_pos}: Odds of positive events in the bin.
#'   \item \code{odds_ratio}: Odds ratio of positive events compared to the total population.
#'   \item \code{lift}: Lift of the bin, calculated as the ratio of the positive rate in the bin to the overall positive rate.
#'   \item \code{ks}: Kolmogorov-Smirnov statistic, measuring the difference between cumulative positive and negative percentages.
#'   \item \code{gini_contribution}: Contribution to the Gini coefficient for each bin.
#' }
#'
#' @examples
#' \dontrun{
#' binning_result <- OptimalBinning(target, feature)
#' gains_table <- OptimalBinningGainsTable(binning_result)
#' }
#'
#' @export
OptimalBinningGainsTable <- function(binning_result) {
    .Call(`_OptimalBinningWoE_OptimalBinningGainsTable`, binning_result)
}

#' Generates a Gains Table from the Weight of Evidence (WoE) and target feature data
#'
#' This function takes a numeric vector of Weight of Evidence (WoE) values and the corresponding binary target variable to generate a gains table. The table includes key metrics such as counts, event rates, cumulative sums, Kolmogorov-Smirnov (KS) statistic, Information Value (IV), odds ratio, lift, and Gini contribution for each unique WoE bin.
#'
#' @param feature_woe Numeric vector representing the Weight of Evidence (WoE) values for each observation.
#' @param target Numeric vector representing the binary target variable, where 1 indicates a positive event (e.g., default) and 0 indicates a negative event (e.g., non-default).
#'
#' @return A data frame containing the following columns for each unique WoE bin:
#' \itemize{
#'   \item \code{bin}: The bin labels.
#'   \item \code{count}: Total count of observations in each bin.
#'   \item \code{pos}: Count of positive events in each bin.
#'   \item \code{neg}: Count of negative events in each bin.
#'   \item \code{woe}: Weight of Evidence (WoE) value for each bin.
#'   \item \code{iv}: Information Value (IV) contribution for each bin.
#'   \item \code{total_iv}: Total Information Value (IV) across all bins.
#'   \item \code{cum_pos}: Cumulative count of positive events up to the current bin.
#'   \item \code{cum_neg}: Cumulative count of negative events up to the current bin.
#'   \item \code{pos_rate}: Rate of positive events in each bin.
#'   \item \code{neg_rate}: Rate of negative events in each bin.
#'   \item \code{pos_perc}: Percentage of positive events relative to the total positive events.
#'   \item \code{neg_perc}: Percentage of negative events relative to the total negative events.
#'   \item \code{count_perc}: Percentage of total observations in each bin.
#'   \item \code{cum_count_perc}: Cumulative percentage of observations up to the current bin.
#'   \item \code{cum_pos_perc}: Cumulative percentage of positive events up to the current bin.
#'   \item \code{cum_neg_perc}: Cumulative percentage of negative events up to the current bin.
#'   \item \code{cum_pos_perc_total}: Cumulative percentage of positive events relative to the total observations.
#'   \item \code{cum_neg_perc_total}: Cumulative percentage of negative events relative to the total observations.
#'   \item \code{odds_pos}: Odds of positive events in each bin.
#'   \item \code{odds_ratio}: Odds ratio of positive events in the bin compared to the total population.
#'   \item \code{lift}: Lift of the bin, calculated as the ratio of the positive rate in the bin to the overall positive rate.
#'   \item \code{ks}: Kolmogorov-Smirnov statistic, measuring the difference between cumulative positive and negative percentages.
#'   \item \code{gini_contribution}: Contribution to the Gini coefficient for each bin.
#' }
#'
#' @details
#' The function assumes that both \code{feature_woe} and \code{target} have the same length. It groups the target values by the unique WoE values, computes various metrics for each group, and returns a comprehensive gains table.
#'
#' @examples
#' \dontrun{
#' feature_woe <- c(-0.5, 0.2, 0.2, -0.5, 0.3)
#' target <- c(1, 0, 1, 0, 1)
#' gains_table <- OptimalBinningGainsTableFeature(feature_woe, target)
#' }
#'
OptimalBinningGainsTableFeature <- function(feature_woe, target) {
    .Call(`_OptimalBinningWoE_OptimalBinningGainsTableFeature`, feature_woe, target)
}

